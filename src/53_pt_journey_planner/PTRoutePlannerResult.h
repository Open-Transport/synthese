
/** PTRoutePlannerResult class header.
	@file PTRoutePlannerResult.h

	This file belongs to the SYNTHESE project (public transportation specialized software)
	Copyright (C) 2002 Hugues Romain - RCS <contact@reseaux-conseil.com>

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#ifndef SYNTHESE_routeplanner_PTRoutePlannerResult_h__
#define SYNTHESE_routeplanner_PTRoutePlannerResult_h__

#include <list>
#include <boost/optional.hpp>

#include "Journey.h"
#include "TimeSlotRoutePlanner.h"

namespace synthese
{
	namespace html
	{
		class HTMLForm;
	}

	namespace geography
	{
		class NamedPlace;
		class Place;
	}

	namespace pt_journey_planner
	{
		//////////////////////////////////////////////////////////////////////////
		/// Public transportation route planner result class.
		///	@ingroup m53
		/// @author Hugues Romain
		//////////////////////////////////////////////////////////////////////////
		/// The route planner result contains 3 main informations :
		///	<ul>
		///		<li>Some informations about the computing process</li>
		///		<li>The list of journeys found by the route planner</li>
		///		<li>A list of places used as the first column of the schedules sheet</li>
		///	</ul>
		///
		///	<h2>List of places for the schedules sheet</h2>
		///
		/// The list of places respects the following rules :
		///	<ul>
		///		<li>Each place used by the journey is present in the list</li>
		///		<li>The order of places in the list is consistant for each journey</li>
		///		<li>If necessary a place can be present several times in the list.</li>
		///		<li>Place repetitions are avoided as much as possible</li>
		///		<li>Origin places are always on the top of the list</li>
		///		<li>Destination places are always on the bottom of the list</li>
		///	</ul>
		///
		/// The list of places is generated by the _buildPlacesList method.
		///
		class PTRoutePlannerResult
		{
		public:
			/** Information about a served place, displayed in a schedule sheet presentation.
			*/
			struct PlaceInformation
			{
				const geography::NamedPlace* place;
				bool isOrigin;
				bool isDestination;
				PlaceInformation(const geography::NamedPlace* _place, bool _isOrigin, bool _isDestination) : place(_place), isOrigin(_isOrigin), isDestination(_isDestination) {}
			};


			/** Vector of served places, to display in a schedule sheet presentation.
			*/
			typedef std::list<PlaceInformation> PlacesList;

			typedef algorithm::TimeSlotRoutePlanner::Result Journeys;

			typedef std::map<Journeys::const_iterator, std::vector<PlacesList::iterator> > JourneysPlacePositions;
			

		private:
			//! @name Informations about the computing process
			//@{
				const geography::Place* const		_departurePlace;
				const geography::Place* const		_arrivalPlace;
				bool		_samePlaces;	//!< Whether the route planning was attempted between to identical places (in this case the result is always empty)
			//@}

			//! @name Journeys found
			//@{
				Journeys	_journeys;		//!< List of the result journeys, ordered by departure time
			//@}

			//! @name Places list
			//@{
				PlacesList	_orderedPlaces;	//!< List of the served places
				JourneysPlacePositions _journeysPlacePositions;
			//@}

			//////////////////////////////////////////////////////////////////////////
			/// @dot
			///	digraph {
			///		e0 [label="next place served by the journey"]
			///		e1 [label="find the lowest position with the place"]
			///		e2 [label="has the place been found ?"]
			///		e3 [label="add the place just after the last position used by the journey"]
			///		e4 [label="is the position after the preceding one ?"]
			///		e5 [label=""]
			///		e3 [label="is it the last place ?]
			/// }
			/// @enddot
			void _buildPlacesList();

			PlacesList::iterator _putPlace(
				PlacesList::value_type value,
				PlacesList::iterator minPos
			);

			PlacesList::iterator _getHighestPosition(
				PlacesList::iterator source,
				PlacesList::iterator target
			) const;

			bool _canBeSwapped(
				PlacesList::iterator source,
				PlacesList::iterator target
			) const;

			void _swap(
				PlacesList::iterator source,
				PlacesList::iterator target
			);


		
		public:
			void operator=(const PTRoutePlannerResult& other);
		
			/** Build of the places list of a future schedule sheet corresponding to a journey vector.
				@author Hugues Romain
				@date 2001-2006

				Le but de la methode est de fournir une liste ordonnee de points d'arret de taille minimale determinant les lignes du tableau de fiche horaire.

				Examples of results after journeys addings :

				Pas 0 : Service ABD (adding of B)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td></tr>
				<tr><td>B</td><td>X</td></tr>
				<tr><td>D</td><td>X</td></tr>
				</table>

				Pas 1 : Service ACD (adding of C)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td></tr>
				<tr><td>B</td><td>X</td><td|</td></tr>
				<tr><td>C</td><td>|</td><td>X</td></tr>
				<tr><td>D</td><td>X</td><td>X</td></tr>
				</table>

				Pas 2 : Service ACBD (change of the order authorized : descente de B au rang C+1)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td><td>X</td></tr>
				<tr><td>B</td><td>X</td><td>|</td><td>|</td></tr>
				<tr><td>C</td><td>|</td><td>X</td><td>X</td></tr>
				<tr><td>D</td><td>X</td><td>X</td><td>-</td></tr>
				</table>

				(permutation)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td><td>X</td></tr>
				<tr><td>C</td><td>|</td><td>X</td><td>X</td></tr>
				<tr><td>B</td><td>X</td><td>|</td><td>X</td></tr>
				<tr><td>D</td><td>X</td><td>X</td><td>X</td></tr>
				</table>

				Pas 3 : Service ABCD (change of the order refused : adding of an other C row)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				<tr><td>C</td><td>|</td><td>X</td><td>X</td><td>|</td></tr>
				<tr><td>B</td><td>X</td><td>|</td><td>X</td><td>X</td></tr>
				<tr><td>C</td><td>|</td><td>|</td><td>|</td><td>X</td></tr>
				<tr><td>D</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				</table>

				Pas 4 : Service AB->CD (service continu BC)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				<tr><td>C</td><td>|</td><td>X</td><td>X</td><td>|</td><td>|</td></tr>
				<tr><td>B</td><td>X</td><td>|</td><td>X</td><td>X</td><td>V</td></tr>
				<tr><td>C</td><td>|</td><td>|</td><td>|</td><td>X</td><td>V</td></tr>
				<tr><td>D</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				</table>

				Pas 5 : Service AED (E insï¿rï¿ avant B pour ne pas rompre la continuitï¿ BC)

				<table class="Tableau" cellspacing="0" cellpadding="5">
				<tr><td>A</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				<tr><td>C</td><td>|</td><td>X</td><td>X</td><td>|</td><td>|</td><td>|</td></tr>
				<tr><td>E</td><td>|</td><td>|</td><td>|</td><td>|</td><td>|</td><td>X</td></tr>
				<tr><td>B</td><td>X</td><td>|</td><td>X</td><td>X</td><td>V</td><td>|</td></tr>
				<tr><td>C</td><td>|</td><td>|</td><td>|</td><td>X</td><td>V</td><td>|</td></tr>
				<tr><td>D</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
				</table>

				Pour chaque trajet, on procede donc par balayage dans l'ordre des gares existantes. Si la gare a relier nï¿est pas trouvï¿e entre la position de la gare prï¿cï¿dente et la fin, deux solutions :
					- soit la gare nï¿est prï¿sente nulle part (balayage avant la position de la precedente) auquel cas elle est crï¿ï¿e et rajoutï¿e ï¿ la position de la gare prï¿cï¿dente + 1
					- soit la gare est prï¿sente avant la gare prï¿cï¿dente. Dans ce cas, on tente de descendre la ligne de la gare recherchï¿e au niveau de la position de la gare prï¿cï¿dente + 1. On contrï¿le sur chacun des trajets prï¿cï¿dents que la chronologie n'en serait pas affectï¿e. Si elle ne l'est pas, alors la ligne est descendue. Sinon une nouvelle ligne est crï¿ï¿e.

				Contrôle de l'échangeabilité :

				Soit \f$ \delta_{l,c}:(l,c)\mapsto\{{1\mbox{~si~le~trajet~}c\mbox{~dessert~la~ligne~}l\atop 0~sinon} \f$

				Deux lignes l et m sont échangeables si et seulement si l'ordre des lignes dont \f$ \delta_{l,c}=1 \f$ pour chaque colonne est respecté.

				Cet ordre s'exprime par la propriété suivante : Si \f$ \Phi \f$ est la permutation pévue, alors

				<img width=283 height=27 src="interface.doxygen_fichiers/image008.gif">

				Il est donc nécessaire à la fois de contrôler la possibilité de permutation, et de la déterminer éventuellement.

				Si <sub><img width=25 height=24
				src="interface.doxygen_fichiers/image009.gif"></sub>est la ligne de la gare
				précédemment trouvée, et <sub><img width=24 height=24
				src="interface.doxygen_fichiers/image010.gif"></sub>ï¿lï¿emplacement de la gare
				souhaitï¿e pour permuter, alors les permutations ï¿ opï¿rer ne peuvent concerner
				que des lignes comprises entre <sub><img width=24 height=24
				src="interface.doxygen_fichiers/image010.gif"></sub>ï¿et <sub><img width=25
				height=24 src="interface.doxygen_fichiers/image009.gif"></sub>. En effet, les
				autres lignes nï¿influent pas.</p>

				En premier lieu il est nï¿cessaire de dï¿terminer lï¿ensemble
				des lignes ï¿ permuter. Cet ensemble est construit en explorant chaque colonne.
				Si <sub><img width=16 height=24 src="interface.doxygen_fichiers/image011.gif"></sub>ï¿est
				lï¿ensemble des lignes ï¿ permuter pour assurer lï¿intï¿gritï¿ des colonnes <sub><img
				width=36 height=27 src="interface.doxygen_fichiers/image012.gif"></sub>, on
				peut dï¿finir cet ensemble en fonction du prï¿cï¿dent <sub><img width=25
				height=24 src="interface.doxygen_fichiers/image013.gif"></sub>&nbsp;: <sub><img
				width=308 height=35 src="interface.doxygen_fichiers/image014.gif"></sub>

				Le but ï¿tant de faire descendre la ligne <sub><img width=24
				height=24 src="interface.doxygen_fichiers/image010.gif"></sub>ï¿vers <sub><img
				width=25 height=24 src="interface.doxygen_fichiers/image009.gif"></sub>, les
				lignes appartenant ï¿ L doivent ï¿tre ï¿changeables avecï¿ les positions <sub><img
				width=216 height=27 src="interface.doxygen_fichiers/image015.gif"></sub>.
				Lï¿ensemble de ces tests doit ï¿tre rï¿alisï¿. Au moindre ï¿chec, lï¿ensemble de la
				permutation est rendu impossible.

				Lï¿ï¿changeabilitï¿ binaire entre deux lignes l et m revient ï¿
				contrï¿ler la propriï¿tï¿&nbsp;<sub><img width=89 height=28
				src="interface.doxygen_fichiers/image016.gif"></sub>.

				Lï¿ï¿changeabilitï¿ totale sï¿ï¿crit donc <sub><img width=145
				height=28 src="interface.doxygen_fichiers/image017.gif"></sub>

				Lï¿algorithme est donc le suivant&nbsp;:
					- Construction de L
					- Contrï¿le dï¿ï¿changeabilitï¿ binaire pour chaque ï¿lï¿ment de L avec
					sa future position
					- Permutation

				<b>Echange</b>&nbsp;:

				Exemple dï¿ï¿change&nbsp;:

				<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=340
				style='width:254.95pt;margin-left:141.6pt;border-collapse:collapse;border:
				none'>
				<tr>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>X</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>X</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>X</p>
				</td>
				</tr>
				</table>

				<span style='position:relative;z-index:16'><span
				style='left:0px;position:absolute;left:398px;top:-1px;width:67px;height:53px'><img
				width=67 height=53 src="interface.doxygen_fichiers/image018.gif"></span></span><span
				style='position:relative;z-index:13'><span style='left:0px;position:absolute;
				left:371px;top:-1px;width:67px;height:52px'><img width=67 height=52
				src="interface.doxygen_fichiers/image019.gif"></span></span><span
				style='position:relative;z-index:12'><span style='left:0px;position:absolute;
				left:349px;top:-1px;width:62px;height:53px'><img width=62 height=53
				src="interface.doxygen_fichiers/image020.gif"></span></span><span
				style='position:relative;z-index:11'><span style='left:0px;position:absolute;
				left:322px;top:-1px;width:69px;height:52px'><img width=69 height=52
				src="interface.doxygen_fichiers/image021.gif"></span></span><span
				style='position:relative;z-index:10'><span style='left:0px;position:absolute;
				left:269px;top:-1px;width:97px;height:53px'><img width=97 height=53
				src="interface.doxygen_fichiers/image022.gif"></span></span><span
				style='position:relative;z-index:14'><span style='left:0px;position:absolute;
				left:455px;top:-1px;width:37px;height:51px'><img width=37 height=51
				src="interface.doxygen_fichiers/image023.gif"></span></span><span
				style='position:relative;z-index:15'><span style='left:0px;position:absolute;
				left:482px;top:-1px;width:33px;height:51px'><img width=33 height=51
				src="interface.doxygen_fichiers/image024.gif"></span></span><span
				style='position:relative;z-index:6'><span style='left:0px;position:absolute;
				left:248px;top:-1px;width:262px;height:53px'><img width=262 height=53
				src="interface.doxygen_fichiers/image025.gif"></span></span><span
				style='position:relative;z-index:5'><span style='left:0px;position:absolute;
				left:221px;top:-1px;width:206px;height:53px'><img width=206 height=53
				src="interface.doxygen_fichiers/image026.gif"></span></span><span
				style='position:relative;z-index:7'><span style='left:0px;position:absolute;
				left:242px;top:-1px;width:97px;height:52px'><img width=97 height=52
				src="interface.doxygen_fichiers/image027.gif"></span></span><span
				style='position:relative;z-index:9'><span style='left:0px;position:absolute;
				left:216px;top:-1px;width:96px;height:52px'><img width=96 height=52
				src="interface.doxygen_fichiers/image028.gif"></span></span><span
				style='position:relative;z-index:8'><span style='left:0px;position:absolute;
				left:193px;top:-1px;width:96px;height:52px'><img width=96 height=52
				src="interface.doxygen_fichiers/image029.gif"></span></span><span
				style='position:relative;z-index:4'><span style='left:0px;position:absolute;
				left:194px;top:-1px;width:103px;height:52px'><img width=103 height=52
				src="interface.doxygen_fichiers/image030.gif"></span></span>

				<table>
				<tr>
				<td>
				<p class=Tableau>X</p>
				</td>
				<td>
				<p class=Tableau>X</p>
				</td>
				<td>
				<p class=Tableau>X</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				<td>
				<p class=Tableau>-</p>
				</td>
				</tr>
				</table>

			*/
			PTRoutePlannerResult(
				const geography::Place* departurePlace,
				const geography::Place* arrivalPlace,
				bool samePlaces,
				const algorithm::TimeSlotRoutePlanner::Result& journeys
			);

			//! @name Getters
			//@{
				bool getSamePlaces() const { return _samePlaces; }
				const Journeys& getJourneys() const { return _journeys; }
				const PlacesList& getOrderedPlaces() const { return _orderedPlaces; }
				const geography::Place* getDeparturePlace() const { return _departurePlace; }
				const geography::Place* getArrivalPlace() const { return _arrivalPlace; }
			//@}
			
			void removeFirstJourneys(size_t value);



			//////////////////////////////////////////////////////////////////////////
			/// Generates an HTML table to display on admin console.
			/// @param stream stream to write the result on
			/// @param resaForm reservation HTML Form. If not defined, the table does not
			///		allow to book any seat.
			/// @param resaRadioFieldName name of radio fields to display if a journey is
			///		bookable.
			void displayHTMLTable(
				std::ostream& stream,
				boost::optional<html::HTMLForm&> resaForm,
				const std::string& resaRadioFieldName
			) const;

			//////////////////////////////////////////////////////////////////////////
			/// Reads the named place from one of the 
			static const geography::NamedPlace* GetNamedPlaceFromLegs(
				const graph::ServicePointer* arrivalLeg,
				const graph::ServicePointer* departureLeg,
				const geography::NamedPlace* defaultValue
			);
		};
	}
}

#endif // SYNTHESE_routeplanner_PTRoutePlannerResult_h__
