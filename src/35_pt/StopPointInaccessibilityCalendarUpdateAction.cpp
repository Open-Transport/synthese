
/** StopPointInaccessibilityCalendarUpdateAction class implementation.
	@file StopPointInaccessibilityCalendarUpdateAction.cpp

	This file belongs to the SYNTHESE project (public transportation specialized software)
	Copyright (C) 2002 Hugues Romain - RCSmobility <contact@rcsmobility.com>

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include "StopPointInaccessibilityCalendarUpdateAction.hpp"

#include "ActionException.h"
#include "CalendarTemplateElementTableSync.h"
#include "CalendarTemplateTableSync.h"
#include "DataSourceLinksField.hpp"
#include "ImportableTableSync.hpp"
#include "ParametersMap.h"
#include "Profile.h"
#include "Request.h"
#include "Session.h"
#include "StopPointInaccessibilityCalendar.hpp"
#include "StopPointInaccessibilityCalendarTableSync.hpp"
#include "StopPointTableSync.hpp"
#include "TransportNetworkRight.h"
#include "User.h"

using namespace std;

namespace synthese
{
	using namespace db;
	using namespace impex;
	using namespace server;
	using namespace security;
	using namespace util;

	namespace util
	{
		template<> const string FactorableTemplate<Action, pt::StopPointInaccessibilityCalendarUpdateAction>::FACTORY_KEY("StopPointInaccessibilityCalendarUpdateAction");
	}

	namespace pt
	{
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_ID = Action_PARAMETER_PREFIX + "_id";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_DATA_SOURCE_LINKS = Action_PARAMETER_PREFIX + "_data_source";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_STOP_POINT_ID = Action_PARAMETER_PREFIX + "_stop_point_id";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_USER_CLASS = Action_PARAMETER_PREFIX + "_user_class";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_CALENDAR_TEMPLATE_ID = Action_PARAMETER_PREFIX + "_calendar_template_id";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_PARENT_CALENDAR_TEMPLATE_ID = Action_PARAMETER_PREFIX + "_parent_calendar_template_id";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_START_HOUR = Action_PARAMETER_PREFIX + "_start_hour";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_END_HOUR = Action_PARAMETER_PREFIX + "_end_hour";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_SERIALIZED_DATE_PERIODS = Action_PARAMETER_PREFIX + "_serialized_date_periods";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_DAILY_TIME_FILTER = Action_PARAMETER_PREFIX + "_daily_time_filter";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_CLEAN_CALENDAR_BEFORE_UPDATE = Action_PARAMETER_PREFIX + "_clean_calendar_before_update";
		const string StopPointInaccessibilityCalendarUpdateAction::PARAMETER_ALLOW_AUTO_CREATION = Action_PARAMETER_PREFIX + "_allow_auto_creation";

		const string StopPointInaccessibilityCalendarUpdateAction::PERIODS_SEPARATOR = ";";
		const string StopPointInaccessibilityCalendarUpdateAction::DATE_SEPARATOR = ",";
		const string StopPointInaccessibilityCalendarUpdateAction::AUTOGENERATED_SUFFIX_NAME = "_AUTOGENERATED_INACCESSIBILITY_CALENDAR";



		ParametersMap StopPointInaccessibilityCalendarUpdateAction::getParametersMap() const
		{
			ParametersMap map;

			if(_stopPointInaccessibilityCalendar)
			{
				map.insert(PARAMETER_ID, _stopPointInaccessibilityCalendar->getKey());
			}

			if(_stopPoint)
			{
				map.insert(PARAMETER_STOP_POINT_ID, _stopPoint->getKey());
			}

			if(_calendarTemplate)
			{
				map.insert(PARAMETER_CALENDAR_TEMPLATE_ID, _calendarTemplate->getKey());
			}

			if(_parentCalendarTemplate)
			{
				map.insert(PARAMETER_PARENT_CALENDAR_TEMPLATE_ID, _parentCalendarTemplate->getKey());
			}

			if(!_dataSourceLinks.empty())
			{
				map.insert(
					PARAMETER_DATA_SOURCE_LINKS,
					DataSourceLinks::Serialize(_dataSourceLinks)
				);
			}

			if(_userClass)
			{
				map.insert(PARAMETER_USER_CLASS, (size_t)*_userClass);
			}

			if(_startHour && !_startHour->is_not_a_date_time())
			{
				map.insert(PARAMETER_START_HOUR, _startHour);
			}

			if(_endHour && !_endHour->is_not_a_date_time())
			{
				map.insert(PARAMETER_END_HOUR, _endHour);
			}

			if(!_datePeriods.empty())
			{
				map.insert(
					PARAMETER_SERIALIZED_DATE_PERIODS,
					serializeDatePeriods(_datePeriods)
				);
			}

			if(_dailyTimeFilter)
			{
				map.insert(PARAMETER_DAILY_TIME_FILTER, *_dailyTimeFilter);
			}

			if(_cleanCalendarBeforeUpdate)
			{
				map.insert(PARAMETER_CLEAN_CALENDAR_BEFORE_UPDATE, *_cleanCalendarBeforeUpdate);
			}

			return map;
		}



		void StopPointInaccessibilityCalendarUpdateAction::_setFromParametersMap(const ParametersMap& map)
		{
			// Datasource link
			_dataSourceLinks = ImportableTableSync::GetDataSourceLinksFromSerializedString(
				map.getDefault<string>(PARAMETER_DATA_SOURCE_LINKS),
				*_env
			);

			string datePeriods = map.getDefault<string>(PARAMETER_SERIALIZED_DATE_PERIODS);
			_datePeriods = unserializeDatePeriods(datePeriods);

			if(map.getDefault<RegistryKeyType>(PARAMETER_STOP_POINT_ID))
			{
				try
				{
					_stopPoint = StopPointTableSync::GetEditable(
						map.get<RegistryKeyType>(PARAMETER_STOP_POINT_ID),
						*_env
					);
				}
				catch(ObjectNotFoundException<StopPoint>&)
				{
					throw ActionException("No such stop point");
				}
			}

			if(map.getDefault<RegistryKeyType>(PARAMETER_CALENDAR_TEMPLATE_ID))
			{
				try
				{
					_calendarTemplate = calendar::CalendarTemplateTableSync::GetEditable(
						map.get<RegistryKeyType>(PARAMETER_CALENDAR_TEMPLATE_ID),
						*_env
					);
				}
				catch(ObjectNotFoundException<calendar::CalendarTemplate>&)
				{
					throw ActionException("No such calendar template");
				}
			}

			if(map.getDefault<RegistryKeyType>(PARAMETER_PARENT_CALENDAR_TEMPLATE_ID))
			{
				try
				{
					_parentCalendarTemplate = calendar::CalendarTemplateTableSync::GetEditable(
						map.get<RegistryKeyType>(PARAMETER_PARENT_CALENDAR_TEMPLATE_ID),
						*_env
					);
				}
				catch(ObjectNotFoundException<calendar::CalendarTemplate>&)
				{
					throw ActionException("No such parent calendar template");
				}
			}

			// Find object by ID if specified
			if(map.getDefault<RegistryKeyType>(PARAMETER_ID))
			{
				try
				{
					_stopPointInaccessibilityCalendar = StopPointInaccessibilityCalendarTableSync::GetEditable(
						map.get<RegistryKeyType>(PARAMETER_ID),
						*_env
					);
				}
				catch(ObjectNotFoundException<StopPointInaccessibilityCalendar>&)
				{
					throw ActionException("No such stop point inaccessibility calendar");
				}
			}
			// Otherwise search by data source
			else if(!_dataSourceLinks.empty())
			{
				ImportableTableSync::ObjectBySource<StopPointInaccessibilityCalendarTableSync> objects(*(_dataSourceLinks.begin()->first), *_env);
				if(objects.contains(_dataSourceLinks.begin()->second))
				{
					_stopPointInaccessibilityCalendar = Env::GetOfficialEnv().getEditableRegistry<StopPointInaccessibilityCalendar>().getEditable(
						(*objects.get(_dataSourceLinks.begin()->second).begin())->getKey()
					);
				}
			}

			// If the object is not found by id nor by datasource, create it if possible
			if(!_stopPointInaccessibilityCalendar && map.getDefault<bool>(PARAMETER_ALLOW_AUTO_CREATION))
			{
				if(_stopPoint && (_calendarTemplate || !_datePeriods.empty()))
				{
					_stopPointInaccessibilityCalendar = boost::shared_ptr<StopPointInaccessibilityCalendar>(
						new StopPointInaccessibilityCalendar(
							StopPointInaccessibilityCalendarTableSync::getId()
						)
					);
				}
				else
				{
					throw ActionException("A stop point and a calendar (or serialized date periods) must be specified when auto creating an inaccessibility calendar");
				}
			}
			else if(!_stopPointInaccessibilityCalendar)
			{
				throw ActionException("No stop point inaccessibility calendar found and cannot create a new one");
			}

			if(map.isDefined(PARAMETER_START_HOUR))
			{
				std::string input_start_hour = map.getDefault<string>(PARAMETER_START_HOUR);
				_startHour = input_start_hour.empty() ?
					boost::posix_time::not_a_date_time :
					boost::posix_time::duration_from_string(input_start_hour);
			}

			if(map.isDefined(PARAMETER_END_HOUR))
			{
				std::string input_end_hour = map.getDefault<string>(PARAMETER_END_HOUR);
				_endHour = input_end_hour.empty() ?
					boost::posix_time::not_a_date_time :
					boost::posix_time::duration_from_string(input_end_hour);
			}

			_userClass = map.getOptional<graph::UserClassCode>(PARAMETER_USER_CLASS);

			_dailyTimeFilter = map.getOptional<bool>(PARAMETER_DAILY_TIME_FILTER);

			_cleanCalendarBeforeUpdate = map.getOptional<bool>(PARAMETER_CLEAN_CALENDAR_BEFORE_UPDATE);
		}



		void StopPointInaccessibilityCalendarUpdateAction::run(
			Request& request
		){
			if(_stopPoint &&
				(!_stopPointInaccessibilityCalendar->get<StopPointer>() ||
				 _stopPointInaccessibilityCalendar->get<StopPointer>()->getKey() != _stopPoint->getKey()
			)){
				_stopPointInaccessibilityCalendar->set<StopPointer>(*_stopPoint);
			}

			if(!_dataSourceLinks.empty())
			{
				BOOST_FOREACH(Importable::DataSourceLinks::value_type& sourceLink, _dataSourceLinks)
				{
					bool alreadyExists(false);
					BOOST_FOREACH(const Importable::DataSourceLinks::value_type& originLink, _stopPointInaccessibilityCalendar->getDataSourceLinks())
					{
						if(sourceLink.first->getKey() == originLink.first->getKey() && sourceLink.second == originLink.second)
						{
							alreadyExists = true;
						}
					}

					if(!alreadyExists)
					{
						_stopPointInaccessibilityCalendar->addCodeBySource(*(sourceLink.first), sourceLink.second);
					}
				}
			}

			if(_startHour)
			{
				_stopPointInaccessibilityCalendar->set<StartHour>(*_startHour);
			}

			if(_endHour)
			{
				_stopPointInaccessibilityCalendar->set<EndHour>(*_endHour);
			}

			if(_userClass)
			{
				_stopPointInaccessibilityCalendar->set<UserClass>(*_userClass);
			}

			if(_dailyTimeFilter)
			{
				_stopPointInaccessibilityCalendar->set<DailyTimeFilter>(*_dailyTimeFilter);
			}

			DBTransaction transaction;
			size_t rank(0);

			if(_calendarTemplate)
			{
				_stopPointInaccessibilityCalendar->set<CalendarTemplatePointer>(*_calendarTemplate);
			}
			else if(!_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>())
			{
				boost::shared_ptr<calendar::CalendarTemplate> newCalendar(
					new calendar::CalendarTemplate(calendar::CalendarTemplateTableSync::getId())
				);
				Env::GetOfficialEnv().getEditableRegistry<calendar::CalendarTemplate>().add(newCalendar);

				newCalendar->setName(
					_stopPointInaccessibilityCalendar->get<StopPointer>()->getName() +
					_stopPointInaccessibilityCalendar->get<StopPointer>()->getCodeBySources() +
					AUTOGENERATED_SUFFIX_NAME
				);

				if(_parentCalendarTemplate)
				{
					newCalendar->setParent(_parentCalendarTemplate.get());
				}

				_stopPointInaccessibilityCalendar->set<CalendarTemplatePointer>(*newCalendar);
			}
			else if(_cleanCalendarBeforeUpdate)
			{
				_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()->clearElements();
				calendar::CalendarTemplateElementTableSync::Clean(
					_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()->getKey(),
					transaction
				);
			}

			if(!_datePeriods.empty())
			{
				BOOST_FOREACH(calendar::CalendarTemplate::Elements::value_type element,_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()->getElements())
				{
					rank = element.first + 1;
				}

				BOOST_FOREACH(DatePeriods::value_type& period, _datePeriods)
				{
					boost::shared_ptr<calendar::CalendarTemplateElement> element(
						new calendar::CalendarTemplateElement(calendar::CalendarTemplateElementTableSync::getId())
					);
					Env::GetOfficialEnv().getEditableRegistry<calendar::CalendarTemplateElement>().add(element);

					element->setCalendar(&(*(_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>())));
					element->setMinDate(period.begin());
					element->setMaxDate(period.end());
					element->setRank(rank);

					rank++;
					_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()->addElement(*element);
				}
			}

			calendar::CalendarTemplateTableSync::Save(&(*_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()), transaction);

			BOOST_FOREACH(const calendar::CalendarTemplate::Elements::value_type& element,_stopPointInaccessibilityCalendar->get<CalendarTemplatePointer>()->getElements())
			{
				calendar::CalendarTemplateElementTableSync::Save(const_cast<calendar::CalendarTemplateElement*>(&(element.second)), transaction);
			}

			StopPointInaccessibilityCalendarTableSync::Save(_stopPointInaccessibilityCalendar.get(), transaction);
			transaction.run();
		}



		bool StopPointInaccessibilityCalendarUpdateAction::isAuthorized(
			const Session* session
		) const {
			return session && session->hasProfile() && session->getUser()->getProfile()->isAuthorized<TransportNetworkRight>(WRITE);
		}



		StopPointInaccessibilityCalendarUpdateAction::DatePeriods StopPointInaccessibilityCalendarUpdateAction::unserializeDatePeriods(
			const std::string& serializedString
		){
			DatePeriods result;
			std::vector<std::string> periods;
			boost::algorithm::split(periods, serializedString, boost::is_any_of(PERIODS_SEPARATOR));

			BOOST_FOREACH(std::string& period, periods)
			{
				std::vector<std::string> bounds;
				boost::algorithm::split(bounds, period, boost::is_any_of(DATE_SEPARATOR));

				if(bounds.size() == 2)
				{
					try
					{
						boost::gregorian::date start = boost::gregorian::from_string(bounds[0]);
						boost::gregorian::date end = boost::gregorian::from_string(bounds[1]);

						if(!start.is_not_a_date() && !end.is_not_a_date())
						{
							result.push_back(boost::gregorian::date_period(start, end));
						}
					}
					catch(Exception&)
					{
						continue;
					}
				}
			}

			return result;
		}



		std::string StopPointInaccessibilityCalendarUpdateAction::serializeDatePeriods(
			const DatePeriods& datePeriods
		) {
			std::stringstream result;

			BOOST_FOREACH(DatePeriods::value_type period, datePeriods)
			{
				result << (result.str().empty() ? string() : PERIODS_SEPARATOR) << period.begin() << DATE_SEPARATOR << period.end();
			}

			return result.str();
		}

		StopPointInaccessibilityCalendarUpdateAction::StopPointInaccessibilityCalendarUpdateAction():
			_userClass(0),
			_dailyTimeFilter(false),
			_cleanCalendarBeforeUpdate(false)
		{}
	}
}
